<IdentifierReference> ::= token::Identifier
<BooleanLiteral> ::= token::literal::Boolean
<IntegerLiteral> ::= token::literal::Integer
<StringLiteral> ::= token::literal::String
<TypeParameterValue> ::=
   <BooleanLiteral> |
   <IntegerLiteral> |
   <IdentifierReference> |
   <Type>
<TypeParameter> ::=
   token::Identifier token::punctuation::Equals
   <TypeParameterValue>
<TypeParameters> ::= <TypeParameter>
   (token::punctuation::Comma <TypeParameter>)*
<Type> ::= token::Identifier
   [ token::punctuation::AngleBracketOpen
     <TypeParameterValues>
     token::punctuation::AngleBracketClose ]

<MessageDataField> ::=
   token::Identifier
   token::punctuation::KeyValueSeparator
   <Type>
   token::punctuation::StatementEnd
<MessageData> ::=
   token::Identifier // identifier name must be "data"
   token::punctuation::KeyValueSeparator
   token::punctuation::CurlyBraceOpen
   <MessageDataField>*
   token::punctuation::CurlyBraceClose

<TokenPart> ::=
   <IdentifierReference> |
   <StringLiteral>

// TokenSequenceOption uses identifier=string pattern (like TypeParameter)
// Valid identifiers are "terminator" and "escape" (contextual, not keywords)
// - terminator: the string that ends this token sequence
// - escape: a sequence that, when found, continues reading instead of terminating
//           (used for HTTP/1.1 header continuation lines: CRLF followed by space)
<TokenSequenceOption> ::=
   token::Identifier  // "terminator" or "escape"
   token::punctuation::Equals
   <StringLiteral>
<TokenSequenceOptions> ::=
   token::punctuation::AngleBracketOpen
   <TokenSequenceOption>
   (token::punctuation::Comma <TokenSequenceOption>)*
   token::punctuation::AngleBracketClose

<TokenSequence> ::=
   token::keyword::Tokens
   <TokenSequenceOptions>?
   token::punctuation::CurlyBraceOpen
   <TokenPart>*
   token::punctuation::CurlyBraceClose

// Legacy terminator syntax (for backward compatibility)
<Terminator> ::=
   <IdentifierReference> // identifier name must be "terminator"
   token::punctuation::CurlyBraceOpen
   <StringLiteral>
   token::punctuation::CurlyBraceClose

// ForLoopOptions uses the same pattern as TokenSequenceOptions
// Valid identifier is "terminator" (contextual, not a keyword)
<ForLoopOptions> ::=
   token::punctuation::AngleBracketOpen
   <TokenSequenceOption>
   (token::punctuation::Comma <TokenSequenceOption>)*
   token::punctuation::AngleBracketClose

<MessageForLoop> ::=
   token::keyword::For
   <ForLoopOptions>?
   <IdentifierReference>
   token::keyword::In
   <IdentifierReference>
   token::punctuation::CurlyBraceOpen
   <MessagePart>*
   token::punctuation::CurlyBraceClose

<MessagePart> ::=
   <TokenSequence> |
   <Terminator> |
   <MessageForLoop>
<MessageSequence> ::= <MessagePart>*
<MessageParts> ::=
   token::Identifier // identifier name must be "parts"
   token::punctuation::CurlyBraceOpen
   <MessagePart>*
   token::punctuation::CurlyBraceClose

<MessageAttribute> ::=
   <IdentifierReference> // identifier name must be "when" or "then" or "agent"
   token::punctuation::KeyValueSeparator
   <IdentifierReference>
   token::punctuation::StatementEnd

<Message> ::=
   token::keyword::Message
   token::literal::String
   token::punctuation::CurlyBraceOpen
   <MessageAttribute>*
   <MessageData>
   <MessageParts>
   token::punctuation::CurlyBraceClose

<ProtocolDescription> ::= <Message>*
