#include <networkprotocoldsl/parser/tree/protocoldescription.hpp>
#include <networkprotocoldsl/sema/analyze.hpp>
#include <networkprotocoldsl/sema/ast/protocol.hpp>

#include <networkprotocoldsl/parser/tree/message.hpp>

#include <networkprotocoldsl/sema/partstoreadactions.hpp>
#include <networkprotocoldsl/sema/partstowriteactions.hpp>

#include <map>
#include <optional>

namespace networkprotocoldsl::sema {

static std::optional<ast::Transition> analyze_write_message(
    const std::shared_ptr<const parser::tree::Message> &message) {
  auto maybe_actions = parts_to_write_actions(message->parts);
  if (!maybe_actions.has_value()) {
    return std::nullopt;
  }
  return std::make_shared<const ast::WriteTransition>(
      ast::WriteTransition{message->data, maybe_actions.value()});
}

static std::optional<ast::Transition> analyze_read_message(
    const std::shared_ptr<const parser::tree::Message> &message) {
  auto maybe_actions = parts_to_read_actions(message->parts);
  if (!maybe_actions.has_value()) {
    return std::nullopt;
  }
  return std::make_shared<const ast::ReadTransition>(
      ast::ReadTransition{message->data, maybe_actions.value()});
}

static std::optional<std::map<std::string, ast::Transition>>
analyze_transitions(
    std::shared_ptr<const parser::tree::ProtocolDescription> &protocol,
    const std::string &agent_name) {
  auto transitions = std::map<std::string, ast::Transition>();
  for (auto &message : *protocol) {
    auto maybe_transition = message.second->agent->name == agent_name
                                ? analyze_write_message(message.second)
                                : analyze_read_message(message.second);
    if (!maybe_transition.has_value()) {
      return std::nullopt;
    }
    transitions[message.first] = maybe_transition.value();
  }
  return transitions;
}

static std::optional<std::shared_ptr<const ast::Agent>> analyze_agent(
    std::shared_ptr<const parser::tree::ProtocolDescription> &protocol,
    const std::string &agent_name) {

  // get the transition generated by each message
  auto maybe_transitions = analyze_transitions(protocol, agent_name);
  if (!maybe_transitions.has_value()) {
    return std::nullopt;
  }
  auto &transitions = maybe_transitions.value();

  // assemble the states and transitions together
  std::map<std::string, std::shared_ptr<ast::State>> states;
  for (auto &message : *protocol) {
    auto when_state = message.second->when->name;
    auto then_state = message.second->then->name;
    // make sure the states are created
    for (const auto &state_name : {when_state, then_state}) {
      if (states.find(state_name) == states.end()) {
        states[state_name] = std::make_shared<ast::State>();
        states[state_name]->name = state_name;
      }
    }
    // we need to add the transition of this message from the when_state to the
    // then_state
    states[when_state]->transitions[message.first] =
        std::make_pair(transitions[message.first], then_state);
  }
  // assemble a map to const states, now that we have the data complete.
  std::map<std::string, std::shared_ptr<const ast::State>> const_states;
  for (const auto &state : states) {
    const_states[state.first] = state.second;
  }
  return std::make_shared<const ast::Agent>(const_states);
}

std::optional<std::shared_ptr<const ast::Protocol>>
analyze(std::shared_ptr<const parser::tree::ProtocolDescription> &protocol) {
  auto maybe_client = analyze_agent(protocol, "Client");
  auto maybe_server = analyze_agent(protocol, "Server");
  if (maybe_client.has_value() && maybe_server.has_value()) {
    return std::make_shared<ast::Protocol>(maybe_client.value(),
                                           maybe_server.value());
  }
  return std::nullopt;
}

} // namespace networkprotocoldsl::sema